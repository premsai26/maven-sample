pipeline{
  agent{ 
    node{
      label "${slave_label}" 
    }
  }
  environment{
    tag="$version.$BUILD_NUMBER"       
    service="$repo_name"
    deployname= "$repo_name-$label"
    env="$label-$repo_name"
    image="$docker_url/dynaflo/$artifact_no_ext:$tag"
    nexus="http://$docker_url"
    gitcred="GitTest"
  }
  
  stages {
    
    stage('Approval'){
      steps {
        script{
          if(params.containsKey('jira_id') && params.containsKey('deploy_time')){
            def transitions = jiraGetIssue idOrKey: "${jira_id}" , site: 'JIRA'		
            echo "${workflow_new_status}"
            def jira_status =  transitions.data.fields.status.name.toString() 
            if (jira_status.equalsIgnoreCase("${workflow_new_status}")){
              echo "workflow status ${jira_status}"
              withEnv(['JIRA_SITE=JIRA']) {
                jiraAddComment idOrKey: "${params.jira_id}", comment: "Build is scheduled for ${env.BUILD_URL}" 
              }
            }
            else{
              currentBuild.rawBuild.result = Result.ABORTED
              echo 'work flo status is ${jira_status} so further script will not be executed'
              withEnv(['JIRA_SITE=JIRA']) {
                jiraAddComment idOrKey: "${params.jira_id}", comment: "Build is scheduled for ${env.BUILD_URL} ,but aborted build because, lack of approval"
              }
              error('Skip-CI')
            }
          }
        }
      }
    }
    
    stage('SCM-Checkout'){
      
      steps{
        
        deleteDir() // Wipe the workspace so we are building completely clean
        
        git branch: "$branch",credentialsId: "$gitcred", url: "$repo_host"
      }
    }
    stage('Docker Image Build and Push To Nexus'){
      when {
        expression{ "$release" == 'build' || "$release" == 'build_deploy'}
      }
      steps{
        sh 'docker build -f "Dockerfile" -t "${repo_name}.$version.$BUILD_NUMBER"  .'  
        withDockerRegistry([ credentialsId: "$Nexus_ID", url: "$nexus" ]){
          sh '''
          docker tag "${repo_name}.$version.$BUILD_NUMBER" "${image}" 
          docker push  "${image}" 
          docker rmi -f "${image}"   "${repo_name}.$version.$BUILD_NUMBER" 
          '''
        }                  
      }
    }
    
    stage('Kubernetes-Deployment'){
      when {
        expression{ "$release" == 'deploy' || "$release" == 'build_deploy'}
      }
      steps{
        withCredentials([azureServicePrincipal("$sp")]) {
          sh '''
          az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET -t $AZURE_TENANT_ID
          az account set -s $AZURE_SUBSCRIPTION_ID '''
        }
        withCredentials([[$class: "FileBinding", credentialsId: "$kube", variable: 'KUBE_CONFIG']]){
          sh '''
          sed -i "s|{ns}|$namespace|g" k8s-blue.yml
          sed -i "s|{ns}|$namespace|g" k8s.yml
          sed -i "s|{APP_ENV}|$branch|g" k8s-blue.yml
          sed -i "s|{APP_ENV}|$branch|g" k8s.yml
          sed -i "s|{Nexus_ID}|$Nexus_ID|g" k8s-blue.yml
          sed -i "s|{Nexus_ID}|$Nexus_ID|g" k8s.yml
          sed -i "s|{replica}|$replica_count|g" k8s-blue.yml
          sed -i "s|{replica}|$replica_count|g" k8s.yml
          sed -i "s|{image}|$image|g" k8s-blue.yml
          sed -i "s|{image}|$image|g" k8s.yml
          
          if [ "$deploy_mode" = "blue-green" ]
          then
          echo "BLUE-GREEN SWITCHING DEPLOYMENT"
          [ "$label" == "blue" ] && deployfile=k8s-blue.yml || deployfile=k8s.yml
          
          kubectl --kubeconfig="${KUBE_CONFIG}" --namespace="${namespace}"  apply -f $deployfile
          
          # Wait until the Deployment is ready by checking the MinimumReplicasAvailable condition.   
          
          READY=$(kubectl --kubeconfig="${KUBE_CONFIG}" --namespace="${namespace}"  get deploy $deployname -o json | jq '.status.conditions[] | select(.reason == "MinimumReplicasAvailable") | .status' | tr -d '"')
          while [[ "$READY" != "True" ]]; do
          READY=$(kubectl --kubeconfig="${KUBE_CONFIG}" --namespace="${namespace}" get deploy $deployname -o json | jq '.status.conditions[] | select(.reason == "MinimumReplicasAvailable") | .status' | tr -d '"')
          sleep 5
          done
          
          # Update the service selector with the new version
          
          kubectl --kubeconfig="${KUBE_CONFIG}" --namespace="${namespace}" patch svc $service -p "{\\"spec\\":{\\"selector\\": {\\"env\\": \\"$env\\"}}}" || true
          elif [ "$deploy_mode" = "rollingupdate" ]
          then
          echo " ROLLING-UPDATE TO EXISTING FLO"
          
          OUT=$( kubectl --kubeconfig="${KUBE_CONFIG}" --namespace="${namespace}" set image deployment $deployname $deployname=${image} --record || true )
          
          if [ $OUT ="error*" ];then
          kubectl  --kubeconfig="${KUBE_CONFIG}" create -f k8s.yml && kubectl  --kubeconfig="${KUBE_CONFIG}" create -f k8s-blue.yml ||kubectl  --kubeconfig="${KUBE_CONFIG}" create -f k8s-blue.yml
          else
          
          echo "ROLLING-UPDATE TO EXISTING FLO SUCCESS!"
          
          fi
          
          elif [ "$deploy_mode" = "none" ]
          then
          echo "CREATING NEW FLO DEPLOYMENT IN KUBERNETES"
          kubectl  --kubeconfig="${KUBE_CONFIG}" create -f k8s.yml && kubectl  --kubeconfig="${KUBE_CONFIG}" create -f k8s-blue.yml ||kubectl  --kubeconfig="${KUBE_CONFIG}" create -f k8s-blue.yml
          
          else
          echo "CREATING NEW FLO DEPLOYMENT IN KUBERNETES"
          kubectl  --kubeconfig="${KUBE_CONFIG}" create -f k8s.yml && kubectl  --kubeconfig="${KUBE_CONFIG}" create -f k8s-blue.yml ||kubectl  --kubeconfig="${KUBE_CONFIG}" create -f k8s-blue.yml
          
          fi	      
          '''
        }
      }
    } 		
  }
  post {
    always{
      script{
        if(params.containsKey('jira_id'))
        {
          withEnv(['JIRA_SITE=JIRA']) {
            jiraAddComment idOrKey: "${params.jira_id}", comment: "deploy completed as ${currentBuild.currentResult}"
          }
        }
      }
      writeFile file: "$WORKSPACE/${params.artifact_no_ext}-${params.version}.${BUILD_NUMBER}.MFY", text: "source_path: http://${params.nexus_url}/repository/${params.artifact_repository}/${params.organization}/${params.artifact_no_ext}/${params.version}.${BUILD_NUMBER}/${params.artifact_no_ext}-${params.version}.${BUILD_NUMBER}.${params.source_env}.${params.artifact_ext}\nstatus: ${currentBuild.currentResult}"
      
      withCredentials([usernamePassword(credentialsId: 'dynaflo-nexus', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')])
      {
        sh'''#!/bin/bash -xe
        curl -v -u $USERNAME:$PASSWORD --upload-file $WORKSPACE/$artifact_no_ext-$version.$BUILD_NUMBER.MFY http://$nexus_url/repository/$artifact_repository/$environment/$organization/$artifact_no_ext/$version.$BUILD_NUMBER/$artifact_no_ext-$version.$BUILD_NUMBER.MFY
        rm -rf temp*.txt
        '''
      }
      emailext ( subject: '${JOB_NAME} ${BUILD_NUMBER} Result:${BUILD_STATUS} ', from: "${jenkins_from_mail}", attachLog: true, compressLog: true, body: '''${SCRIPT, template="groovy-html.template"} <html><head></head><body><div><p class=MsoNormal><span style='font-size:10.0pt;font-family:"Georgia",serif'>Regards,<o:p></o:p></span></p><p class=MsoNormal><img width=100 height=10 style='width:1.0416in;height:.1083in' id="_x0000_i1026" src="http://www.chubb.com/common/images/CHUBB_Logo_Purple.png" alt="Chubb Logo"><br><br><b><span style='font-size:10.0pt;font-family:"Georgia",serif;color:black'>DevOps Support</span></b><span style='font-size:10.0pt;font-family:"Georgia",serif;color:black'><br>Digital DevOps<br>Jenkins Prod <br><o:p></o:p></p><a href="mailto:DIO_Support@chubb.com?Subject=Support on Jenkins" target="_top">Need Support</a></span></div></body></html>''', mimeType: 'text/html', to: '${mail_users_list}')
    }
    
    success{
      script{
        try{
          def git_url = "$repo_host".tokenize('/')[0]+"//"+"$repo_host".tokenize('/')[1]
          withCredentials([usernamePassword(credentialsId: 'GitTest', passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {               
            httpRequest acceptType: 'APPLICATION_JSON', contentType: 'APPLICATION_JSON', httpMode: 'POST', ignoreSslErrors: true, requestBody: """{
              "environment": "dev",
              "dynaflo_env": "$branch",
              "test_type" : "$type",
              "orgName": "$smoke_test_org",
              "repoName": "$smoke_test_repo",
              "GitUrl": "$git_url",
              "username": "${GIT_USERNAME}",
              "token": "${GIT_PASSWORD}",
              "commitType": "yaml"                             
              }""", responseHandle: 'LEAVE_OPEN', url: "${koko_url}", validResponseCodes: '100:500'
              
            }
            
          }
          catch(e){
            echo "KOKO service issue"
          }
        }
      }
      
      
      
    }
  }
 
